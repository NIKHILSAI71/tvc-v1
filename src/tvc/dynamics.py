"""JAX-based planar rocket dynamics used for predictive control design.

The physics encoded here approximates the MuJoCo model closely enough to allow
fast linearisation and MPC updates on GPU via JAX. These routines serve as the
prediction model inside the MPC solver and also power curriculum-dependent
stabilisers that require differentiable dynamics.
"""
from __future__ import annotations

from dataclasses import dataclass
from typing import Callable, Tuple

import chex
import jax
import jax.numpy as jnp


@dataclass(frozen=True)
class RocketParams:
    """Physical parameters that characterise the planar rocket model.

    Args:
        mass: Vehicle mass (kg).
        inertia: Moment of inertia about the pitch axis (kg·m²).
        thrust: Nominal thrust magnitude (N).
        arm: Lever arm between nozzle pivot and centre of mass (m).
        damping: Aerodynamic pitch damping coefficient.
        gravity: Gravitational acceleration (m/s²).
    """

    mass: float = 45.0
    inertia: float = 120.0
    thrust: float = 470.0
    arm: float = 1.75
    damping: float = 4.0
    gravity: float = 9.81


@chex.dataclass
class RocketState:
    """Structured view of the planar rocket state vector."""

    x: float
    z: float
    vx: float
    vz: float
    theta: float
    omega: float

    def as_array(self) -> jnp.ndarray:
        return jnp.array([self.x, self.z, self.vx, self.vz, self.theta, self.omega])

    @classmethod
    def from_array(cls, state: jnp.ndarray) -> "RocketState":
        return cls(*state)


def rocket_step(state: jnp.ndarray, control: jnp.ndarray, dt: float, params: RocketParams) -> jnp.ndarray:
    """Discrete dynamics update for the planar rocket model.

    Args:
        state: Array ``[x, z, vx, vz, theta, omega]`` describing position/orientation.
        control: Array ``[ux, uy]`` representing lateral TVC offsets (meters).
        dt: Integration step (seconds).
        params: Physical constants used during integration.

    Returns:
        The next state following a semi-implicit Euler integration step.
    """

    ux, uy = control
    x, z, vx, vz, theta, omega = state

    thrust = params.thrust
    mass = params.mass
    inertia = params.inertia

    # Effective thrust vector generated by the nozzle displacement.
    lateral_force = thrust * (ux / params.arm)
    axial_force = thrust * (1.0 - 0.08 * uy)

    ax = lateral_force / mass
    az = (axial_force / mass) - params.gravity

    # Pitch torque due to lateral thrust plus damping.
    torque = params.arm * lateral_force - params.damping * omega
    alpha = torque / inertia

    vx_next = vx + dt * ax
    vz_next = vz + dt * az
    omega_next = omega + dt * alpha
    theta_next = theta + dt * omega_next

    x_next = x + dt * vx_next
    z_next = z + dt * vz_next

    return jnp.stack([x_next, z_next, vx_next, vz_next, theta_next, omega_next])


def linearise_dynamics(
    state: jnp.ndarray, control: jnp.ndarray, dt: float, params: RocketParams
) -> Tuple[jnp.ndarray, jnp.ndarray]:
    """Computes discrete-time Jacobians for MPC around a reference trajectory."""

    def transition(s, u):
        return rocket_step(s, u, dt, params)

    A = jax.jacfwd(transition, argnums=0)(state, control)
    B = jax.jacfwd(transition, argnums=1)(state, control)
    return A, B


def simulate_rollout(
    state: jnp.ndarray,
    controls: jnp.ndarray,
    dt: float,
    params: RocketParams,
) -> jnp.ndarray:
    """Propagates the dynamics over a control horizon using ``jax.lax.scan``."""

    def scan_fn(carry, u):
        nxt = rocket_step(carry, u, dt, params)
        return nxt, nxt

    _, states = jax.lax.scan(scan_fn, state, controls)
    return states


def build_transition_function(params: RocketParams, dt: float) -> Callable[[jnp.ndarray, jnp.ndarray], jnp.ndarray]:
    """Returns a JIT-compiled transition map for the supplied parameters."""

    @jax.jit
    def transition(state: jnp.ndarray, control: jnp.ndarray) -> jnp.ndarray:
        return rocket_step(state, control, dt, params)

    return transition
